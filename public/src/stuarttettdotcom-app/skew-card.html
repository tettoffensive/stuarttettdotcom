<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.4/TweenLite.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.4/TimelineLite.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.4/plugins/CSSPlugin.min.js"></script>
<!-- cubic-bezier(0.15, 0.005, 0.155, 1) -->
<dom-module id="skew-card">
  <template>
    <style>
    :host {
      cursor: pointer;
      background-color: #ffffff;
      color: #000;
      padding: 0px;
      overflow: hidden;
      padding: 1px;
      -webkit-backface-visibility:hidden;
      backface-visibility:hidden;
      -webkit-background-clip:content-box;
      background-clip:content-box;
      outline: 1px solid transparent;
      transform-origin: left top;

      display: flex;
      flex-direction: row;
      flex-wrap: nowrap;
      align-items: flex-start;
    }

    :host(.front) {
      z-index: 100;
    }

    :host(.back) {
      z-index: 0;
    }

    :host(.initial) {
      transform: skewY(-3deg);
      height: 256px;
      width: 100%;
    }

    :host(.returning) {
      height: 256px;
      width: 100%;
    }

    :host::transitioning {
      pointer-events: none;
    }

    :host(.onclick) {
      height: 80%;
      width: 80%;
      position: absolute;
      left: 10%;
      top: 10%;
    }

    :host(.initial) > * {
      transform: skewY(3deg);
    }

    .content {
      flex-grow: 1;
      flex-shrink: 1;
      position: relative;
      transform-origin: 0px 26px; /* should be 25px, but something is causing a bit of a jump */
    }

    .content img {
      margin: auto;
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }

    .content:before {
      display: block;
      content: ' ';
      width: 100%;
      padding-top: calc(503 / 578 * 100%);
    }

    .label {
      position: relative;
      top: -25px;
      left: 0;
      right: 0;
      overflow: hidden;
      background-color: #3F4A48;
      color: #ffffff;
      height: 112%;
      width: 280px;
      transform-origin: 0px 25px;
      z-index: 1;
    }

    .label .text {
      position: relative;
      left: 0;
      top: 0;
      right: 0;
      width: 280px;
      /* height: 100%; */
      transform-origin: 0px 6px;
    }

    .t2 {
      font-family: 'BioRhyme';
      font-weight: 800;
      font-style: normal;
      font-size: 18px;
      color: #FFFFFF;
      letter-spacing: 1px;
      text-align: left;
    }

    .d2 {
      font-family: 'Space Mono';
      font-size: 14px;
      font-weight: 400;
      font-style: italic;
    }

    .label p { padding: 20px; }

    :host(.initial):hover {
      /* height: 512px; */
    }

    </style>
    <div class="label">
      <div class="text">
        <p class="t2">[[title]]</p></a>
        <p class="d2">[[description]]</p>
      </div>
    </div>
    <div class="content">
      <img src="[[img]]" />
    </div>
  </template>

  <script>
  // otherwise GSAP skewY != css skewY https://greensock.com/docs/Plugins/CSSPlugin
  CSSPlugin.defaultSkewType = "simple";

  class SkewCard extends Polymer.Element {
    static get is() { return 'skew-card'; }
    static get properties() {
      return {
        title: {
          type: String,
          reflectToAttribute: true,
        },
        description: {
          type: String,
          reflectToAttribute: true,
        },
        img: {
          type: String,
          reflectToAttribute: true,
        },
        link: {
          type: String,
          reflectToAttribute: true,
        },
      }
    }

    ready() {
      // add default classes
      this.classList.add('initial');
      this.classList.add('back');
      this.addEventListener('click', this._onClick);
      super.ready();
      // keep track of default title
      this._defaultTitle = document.title;
    }

    constructor() {
      super();
      // closed state = false
      this._state = false;
      // for history back and forward buttons
      this._popState = this._popState.bind(this);
    }

    get defaultTitle() {
      return this._defaultTitle;
    }

    get state() {
      return this._state;
    }

    set transitionToState(value) {
      if (this._state == value) {
        throw "Trying to transition to an unsupported state";
      }
      this._state = value;
    }

    connectedCallback() {
      super.connectedCallback();
      // for history back and forward buttons
      window.addEventListener('popstate', this._popState);
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      // for history back and forward buttons
      window.removeEventListener('popstate', this._popState);
    }

    _loadPageData() {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', 'builduptv/index.html');
      xhr.onload = function() {
        if (xhr.status === 200) {
          // alert('hello there: ' + xhr.responseText);
          // var newContent = xhr.responseText.find('#content');
          // var newPage = $(newContent).attr('data-page');
          // var tempElement = document.createElement('div');
          // tempElement.innerHTML = data;
          // var styles = tempElement.querySelector('#ce-fontset').innerHTML;
          // document.querySelector('#ce-fontset').innerHTML = styles;
          //
          // $(newContent).addClass('ed-page--new');
          // $('#content').before(newContent);
          // pages.updateMetaData(newContent, oldPage);
          // pages.updatePath(newPage, href);
          // pages.checkExternalLinks();
          // casePage.init();
          // if (workCase) {
          //   pages.animateCase(oldPage, newPage, workCase);
          // } else {
          //   pages.animatePages(oldPage, newPage);
          // }
          // this.set('resolveUrl', event.target.value);
          // this.set('title', xhr.response.detail.response.title);
        } else {
          alert('Request failed.  Returned status of ' + xhr.status);
        }
      };

      // Calculate the time from starting to load the data for use in animation timing
      var startLoad = performance.now();
      xhr.send(); // send the request
    }

    // Called when you click on a closed card
    _openCard() {
      this.transitionToState = true; // transition to open
      // Load the data for the opening page async - don't wait for the data to animate
      this._loadPageData();

      // FLIP animation
      // First
      let transform = this.style.transform;
      this.style.transform = "none"; // without skew
      let first = this.getBoundingClientRect();
      this.style.transform = transform; // restore skew
      // Last
      this.classList.replace('back','front');
      this.classList.replace('initial','onclick');
      let last = this.getBoundingClientRect();
      // Invert
      let deltaX = first.left - last.left;
      let deltaY = first.top - last.top;
      let deltaW = first.width / last.width;
      let deltaH = first.height / last.height;
      // Create transforms
      let thisFromTransform = `
      translate(${deltaX}px, ${deltaY}px)
      skewY(-3deg)
      scale(${deltaW}, ${deltaH})
      `;
      let thisToTransform = `
      translate(0,0)
      scale(1,1)
      skewY(0deg)
      `;
      // Animate
      var t1 = new TimelineLite();
      t1.addLabel("openCard", 0);
      let duration = 0.5;
      // shadow
      t1.add( TweenLite.to(this, duration, {boxShadow: "0 30px 60px rgba(0, 0, 0, 0.35)"}),"openCard");
      // transform
      t1.add( TweenLite.fromTo(this, duration, {transform: thisFromTransform, force3D: true}, {transform: thisToTransform,
        force3D: true, // fixes glitch in Safari
        onUpdate: () => {
          // Invert scale for children to maintain text size
          let sx = 1.0/this._gsTransform.scaleX;
          let sy = 1.0/this._gsTransform.scaleY;
          let skewY = -this._gsTransform.skewX; // for some reason GSAP skewY=0 and GSAP skewX=CSS skewY
          Array.from(this.shadowRoot.children).forEach( child => {
            TweenLite.set(child, {scaleX : sx, scaleY: sy, skewY: skewY});
          });
        },
        onComplete: () => {
          this.style.transform = ""; // using clearProps messes up last iteration of onUpdate
          Array.from(this.shadowRoot.children).forEach( child => {
            child.style.transform = "";
          });
        },
        ease: Power3.easeInOut,
      }), "openCard");
      // Page history
      document.title = "new title";
      history.pushState(null, null, "new-page");
    }

    // Called when you click on a opened card or back button
    _closeCard() {
      this.transitionToState = false; // close the card
      // FLIP animation
      // First
      let first = this.getBoundingClientRect();
      // Last
      this.classList.replace('onclick','returning');
      let transform = this.style.transform;
      this.style.transform = ""; // without skew
      let last = this.getBoundingClientRect();
      this.style.transform = transform; // restore skew
      // Invert
      let deltaX = first.left - last.left;
      let deltaY = first.top - last.top;
      let deltaW = first.width / last.width;
      let deltaH = first.height / last.height;
      // Create transform
      let thisFromTransform = `
      translate(${deltaX}px, ${deltaY}px)
      scale(${deltaW}, ${deltaH})
      skewY(0deg)
      `;
      let thisToTransform = `
      translate(0,0)
      scale(1,1)
      skewY(-3deg)
      `;
      // Animate
      var t2 = new TimelineLite();
      t2.addLabel("closeCard", 0);
      let duration = 0.5;
      // shadow
      t2.add( TweenLite.to(this, duration, {boxShadow: "none"}),"openCard");
      // transform
      t2.add( TweenLite.fromTo(this, duration, {transform: thisFromTransform, force3D: true}, {transform: thisToTransform,
        force3D: true, // for buggy animation glitch in Safari
        onUpdate: () => {
          // Invert the scale for children and grandchildren to maintain text size
          let sx = 1.0/this._gsTransform.scaleX;
          let sy = 1.0/this._gsTransform.scaleY;
          let skewY = -this._gsTransform.skewX; // for some reason GSAP skewY=0 and GSAP skewX=CSS skewY
          Array.from(this.shadowRoot.children).forEach( child => {
            if (child.classList.contains('label')) {
              TweenLite.set(child, {scaleX: sx, skewY: skewY}); // only counter the width of the dark background
              Array.from(child.children).forEach( grandchild => {
                TweenLite.set(grandchild, {scaleY: sy}); // parent is scaled down in width, add in the scale down in height for text
              });
            } else {
              TweenLite.set(child, {scaleX : sx, scaleY: sy, skewY: skewY });
            }
          });
        },
        onComplete: () => {
          // move back in z-index
          this.classList.replace('front','back');
          // return to regularly scheduled CSS
          this.classList.replace('returning','initial');
          // Set the page title back
          document.title = this.defaultTitle;
          // using clearProps messes up last iteration of onUpdate
          this.style.transform = "";
          Array.from(this.shadowRoot.children).forEach( child => {
            Array.from(this.shadowRoot.children).forEach( grandchild => {
              grandchild.style.transform = "";
            });
            child.style.transform = "";
          });
        },
        ease: Power3.easeInOut
      }),
      "closeCard");
    }

    _onClick(event) {
      if (event.target != event.currentTarget) {
        return;
      }
      event.preventDefault();
      this.state ? this._closeCard() : this._openCard();
    }

    _popState(event) {
      if (event.target != event.currentTarget || !this.state) {
        return; // event is window so this probably isn't necessary
      }
      this.state ? this._closeCard() : this._openCard();
    }

    _loadImage(img) {
      if (img && !img.src) {
        img.src = img.getAttribute('data-src');
      }
    }
  }
  window.customElements.define(SkewCard.is, SkewCard);
  </script>
</dom-module>
