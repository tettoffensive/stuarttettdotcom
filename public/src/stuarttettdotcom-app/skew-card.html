<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.4/TweenLite.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.4/TimelineLite.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.4/plugins/CSSPlugin.min.js"></script>
<!-- cubic-bezier(0.15, 0.005, 0.155, 1) -->
<dom-module id="skew-card">
  <template>
    <style include="skew-style-module">
    /* In different browsers figure,p margin/padding is different */
    :host {
      --card-closed-height: 500px;

      transform-origin: left top;
      cursor: pointer;
      background-color: transparent;
      padding: 0px;
      /* Different browsers alias skewY differently - chrome kinda sucks */
      -webkit-backface-visibility:hidden;
      backface-visibility:hidden;
      -webkit-background-clip:content-box;
      background-clip:content-box;
      outline: 1px solid transparent;

      display: flex;
      flex-direction: row;
      flex-wrap: nowrap;
      align-items: stretch;
    }

    /*  When animating open, put host in front */
    :host(.front) {
      z-index: 1;
    }
    /*  When animating closed, put host back */
    :host(.back) {
      z-index: 0;
    }

    /*  Initial Skewed State */
    :host(.initial) {
      transform: skewY(-3deg);
      height: var(--card-closed-height);
      width: 100%;
    }

    /*  When animating closed. Everything in initial but the skew */
    :host(.returning) {
      height: var(--card-closed-height);
      width: 100%;
    }

    /* When user clicks, this class replaces .initial class */
    :host(.onclick) {
      height: 80%;
      width: 80%;
      position: absolute;
      left: 10%;
      top: 10%;
    }

    /* Counter host skewY with an equal and opposite skew */
    :host(.initial) #label, #content {
      transform: skewY(3deg);
    }

    </style>
    <div id="labelShadow" class="shadow z2 lbl-initial">
      <div id="labelClip" class="clip dark-background">
        <div id="label" class="label">
          <div id="text" class="text clip">
            <p class="title">[[title]]</p></a>
            <p class="description">[[description]]</p>
          </div>
        </div>
      </div>
    </div>
    <div id="contentShrink" class="content-shrink shadow z1 ct-initial">
      <div id="contentClip" class="clip">
        <figure id="content" class="content image cover" style="background-image: url([[img]])">
        </div>
      </div>
    </figure>
  </template>

  <script>
  // otherwise GSAP skewY != css skewY https://greensock.com/docs/Plugins/CSSPlugin
  CSSPlugin.defaultSkewType = "simple";

  // Used for interpotalion in the animation for closing the card
  function remap(x, inMin, inMax, outMin, outMax) {
    let remap = (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
    return Math.min(Math.max(remap, outMin), outMax);
  }

  // function imageCover( imageRect, containerRect) {
  //   let imageWidth = imageRect.width;
  //   let imageHeight = imageRect.height;
  //   let containerWidth = containerRect.width;
  //   let containerHeight = containerRect.height;
  //   let imageRatio = imageHeight / imageWidth;
  //   let containerRatio = containerHeight / containerWidth;
  //   let coverImageSize = (containerRatio > imageRatio) ? { width: (containerHeight / imageRatio), height: containerHeight} : { width: containerWidth, height: (containerWidth / imageRatio) };
  //   let returnValue = { x: (coverImageSize.width / imageRect.width ), y: (coverImageSize.height / imageRect.height) };
  //   console.log(`{ x: (${imageRect.width} / ${coverImageSize.width}), y: (${imageRect.height} / ${coverImageSize.height}) };`)
  //   return returnValue;
  // }

  class SkewCard extends Polymer.Element {
    static get is() { return 'skew-card'; }
    static get properties() {
      return {
        title: {
          type: String,
          reflectToAttribute: true,
        },
        description: {
          type: String,
          reflectToAttribute: true,
        },
        img: {
          type: String,
          reflectToAttribute: true,
        },
        link: {
          type: String,
          reflectToAttribute: true,
        },
      }
    }

    ready() {
      // add default classes
      this.classList.add('initial');
      this.classList.add('back');
      // this.addEventListener('click', this._onClick);
      super.ready();
      // keep track of default title
      this._defaultTitle = document.title;
      this.domReady = true;
    }

    constructor() {
      super();
      // closed state = false
      this._state = false;
      this._tl = null;
      // for history back and forward buttons
      this._popState = this._popState.bind(this);
    }

    get defaultTitle() {
      return this._defaultTitle;
    }

    get state() {
      return this._state;
    }

    set transitionToState(value) {
      if (this._state == value) {
        throw "Trying to transition to an unsupported state";
      }
      this._state = value;
    }

    connectedCallback() {
      super.connectedCallback();
      // for history back and forward buttons
      window.addEventListener('popstate', this._popState);
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      // for history back and forward buttons
      window.removeEventListener('popstate', this._popState);
    }

    // _loadPageData() {
    //
    //   return;
    //   var xhr = new XMLHttpRequest();
    //   xhr.overrideMimeType('application/xml')
    //   xhr.open('GET', 'builduptv/index.html');
    //   xhr.onload = function() {
    //     if (xhr.status === 200) {
    //       // alert('hello there: ' + xhr.responseText);
    //       // let parser = new DOMParser();
    //       // var xmlDoc = parser.parseFromString(xhr.responseText,"text/xml");
    //       // console.log(xmlDoc);
    //       var newContent = xhr.responseXML.getElementsByTagName("body")[0];
    //       let docBody = document.getElementsByTagName("body")[0];
    //       console.log(docBody);
    //       docBody.replaceChild(newContent.firstElementChild,docBody.firstElementChild);
    //       return;
    //       // var newPage = $(newContent).attr('data-page');
    //       // $(newContent).addClass('ed-page--new');
    //       // $('#content').before(newContent);
    //       // pages.updateMetaData(newContent, oldPage);
    //       // pages.updatePath(newPage, href);
    //       // pages.checkExternalLinks();
    //       // casePage.init();
    //       // if (workCase) {
    //       //   pages.animateCase(oldPage, newPage, workCase);
    //       // } else {
    //       //   pages.animatePages(oldPage, newPage);
    //       // }
    //       // this.set('resolveUrl', event.target.value);
    //       // tÂ¡his.set('title', xhr.response.detail.response.title);
    //     } else {
    //       alert('Request failed.  Returned status of ' + xhr.status);
    //     }
    //   };
    //
    //   // Calculate the time from starting to load the data for use in animation timing
    //   var startLoad = performance.now();
    //   xhr.send(); // send the request
    // }

    // Called when you click on a closed card
    _openCard(callback) {
      this.transitionToState = true; // transition to open
      // Load the data for the opening page async - don't wait for the data to animate

      // FLIP animation
      let animLabelSource = this.$.labelShadow;
      let animImageSource = this.$.contentShrink;
      // First
      let transform = this.style.transform;
      this.style.transform = "none"; // without skew
      let first = animLabelSource.getBoundingClientRect();
      let imageFirst = animImageSource.getBoundingClientRect();
      this.style.transform = transform; // restore skew

      // let's move the element out of the dom
      let animLabelDest = animLabelSource.cloneNode(true);
      animLabelDest.style.visibility = "hidden";
      this.parentElement.parentElement.appendChild(animLabelDest);

      let animImageDest = animImageSource.cloneNode(true);
      animImageDest.style.visibility = "hidden";
      this.parentElement.parentElement.appendChild(animImageDest);

      // Last
      animLabelDest.classList.replace('lbl-initial','lbl-onclick');
      let last = animLabelDest.getBoundingClientRect();
      animImageDest.classList.replace('ct-initial','ct-onclick');
      let imageLast = animLabelDest.getBoundingClientRect();
      // Invert
      let deltaX = first.left - last.left;
      let deltaY = first.top - last.top;
      let deltaW = first.width / last.width;
      let deltaH = first.height / last.height;
      // Invert
      let ideltaX = imageFirst.left - imageLast.left;
      let ideltaY = imageFirst.top - imageLast.top;
      let ideltaW = imageFirst.width / imageLast.width;
      let ideltaH = imageFirst.height / imageLast.height;
      // Create transforms
      let fromTransform = `
      translate(${deltaX}px, ${deltaY}px)
      scale(${deltaW}, ${deltaH})
      `;
      let imageFromTransform = `
      translate(${ideltaX}px, ${ideltaY}px)
      scale(${ideltaW}, ${ideltaH})
      `
      let toTransform = `
      translate(0,0)
      scale(1,1)
      `;
      // Animate
      var tl = new TimelineLite({ paused: true });
      // Put the destination pieces in their "First" states
      TweenLite.set(animLabelDest, {transform: fromTransform, transformOrigin: "left top"});
      TweenLite.set(animImageDest, {transform: imageFromTransform, transformOrigin: "right top"});

      let unskewDuration = 0.15;
      var delay = 0;
      tl.addLabel("unskewLabel", delay);
      delay += unskewDuration;

      let scaleUpLabelDuration = 0.15;
      tl.addLabel("scaleUpLabel", delay);
      delay += scaleUpLabelDuration;

      delay = 0.01; // reset
      let fadeOutImageDuration = 0.25;
      tl.addLabel("fadeOutImage", delay);
      delay += fadeOutImageDuration;

      let unskewContentDuration = 0.15;
      tl.addLabel("unskewContentDuration", delay);
      delay += unskewContentDuration;

      let scaleUpContentDuration = 0.15;
      tl.addLabel("scaleUpContent", delay);
      delay += scaleUpContentDuration;

      // Unskew Label
      tl.add( TweenLite.to(this.$.label, unskewDuration, { alpha: 0 }), "unskewLabel");
      tl.add( TweenLite.to(this.$.labelShadow, unskewDuration, {skewY: 3, skewType: "simple", transformOrigin: "left top",
      force3D: true, // fixes glitch in Safari
      onUpdate: () => {
        let skewY = -this.$.labelShadow._gsTransform.skewY;
        TweenLite.set(this.$.label, {skewY: skewY, skewType: "simple", transformOrigin: "left top"});
      },
      onComplete: () => {
        animLabelDest.style.visibility = "";
        animLabelDest.querySelector(".label").style.visibility = "hidden";
        animLabelSource.style.visibility = "hidden";
      },
      onReverseComplete: () => {
        animLabelDest.style.visibility = "hidden";
        animLabelDest.querySelector(".label").style.visibility = "";
        animLabelSource.style.visibility = "";
      },
      ease: Power3.easeIn,
    }), "unskewLabel");
    // Scale Up Label
    tl.add( TweenLite.to(animLabelDest, scaleUpLabelDuration,
      { transform: toTransform,
        transformOrigin: "left top",
        force3D: true,
        ease: Power3.easeOut,
      }), "scaleUpLabel");
      // Fade Out the content Image
      tl.add( TweenLite.to(this.$.content, fadeOutImageDuration,
        {
          backgroundImage: '',
          // backgroundColor: '#54F0CE',
          ease: Power3.easeInOut,
        }), "fadeOutImage");
        // Unskew
        tl.add( TweenLite.to(this.$.content, unskewContentDuration,
          {
            skewY: 3, skewType: "simple", transformOrigin: "right top",
            onUpdate: () => {

            }, onComplete: () => {
              animImageDest.style.visibility = "";
              let content = animImageDest.querySelector(".content");
              content.style.backgroundImage = "";
              animImageSource.style.visibility = "hidden";
            },
            onReverseComplete: () => {
              animImageDest.style.visibility = "hidden";
              let content = animImageDest.querySelector(".content");
              // TODO: restore background image
              // content.style.backgroundImage = "";
              animImageSource.style.visibility = "";
            },
            ease: Power3.easeIn,
          }), "unskewContentDuration");
        // Scale Up
        tl.add( TweenLite.to(animImageDest, scaleUpContentDuration, {transform: toTransform,
        force3D: true, // fixes glitch in Safari
        onUpdate: () => {
          let sx = 1.0/animLabelDest._gsTransform.scaleX;
          let sy = 1.0/animLabelDest._gsTransform.scaleY;
          let content = animImageDest.children[0];
          // let content = animImageDest.querySelector(".content");
          TweenLite.set(content, { scaleX: sx, scaleY: sy, transformOrigin: "right top"});
        }, onComplete: () => {
          setTimeout(() => {
            callback(animLabelDest,animImageDest);
          },1);
        },
        onReverseComplete: () => {
          alert("reverse complete!!!");
          setTimeout(() => {
            callback(animLabelDest,animImageDest);
          },1);
        },
        ease: Power3.easeOut,
      }), "scaleUpContent");
      tl.restart();
      this._tl = tl;
    }

    // Called when you click on a closed card
    _closeCard(callback) {
      this.transitionToState = false; // transition to open
      this._tl.reverse();
      console.log("F");
    //   // Load the data for the opening page async - don't wait for the data to animate
    //
    //   // FLIP animation
    //   let animLabelSource = this.$.labelShadow;
    //   let animImageSource = this.$.contentShrink;
    //   // First
    //   let transform = this.style.transform;
    //   this.style.transform = "none"; // without skew
    //   let first = animLabelSource.getBoundingClientRect();
    //   let imageFirst = animImageSource.getBoundingClientRect();
    //   this.style.transform = transform; // restore skew
    //
    //   // let's move the element out of the dom
    //   let animLabelDest = animLabelSource.cloneNode(true);
    //   animLabelDest.style.visibility = "hidden";
    //   this.parentElement.parentElement.appendChild(animLabelDest);
    //
    //   let animImageDest = animImageSource.cloneNode(true);
    //   animImageDest.style.visibility = "hidden";
    //   this.parentElement.parentElement.appendChild(animImageDest);
    //
    //   // Last
    //   animLabelDest.classList.replace('lbl-initial','lbl-onclick');
    //   let last = animLabelDest.getBoundingClientRect();
    //   animImageDest.classList.replace('ct-initial','ct-onclick');
    //   let imageLast = animLabelDest.getBoundingClientRect();
    //   // Invert
    //   let deltaX = first.left - last.left;
    //   let deltaY = first.top - last.top;
    //   let deltaW = first.width / last.width;
    //   let deltaH = first.height / last.height;
    //   // Invert
    //   let ideltaX = imageFirst.left - imageLast.left;
    //   let ideltaY = imageFirst.top - imageLast.top;
    //   let ideltaW = imageFirst.width / imageLast.width;
    //   let ideltaH = imageFirst.height / imageLast.height;
    //   // Create transforms
    //   let fromTransform = `
    //   translate(${deltaX}px, ${deltaY}px)
    //   scale(${deltaW}, ${deltaH})
    //   `;
    //   let imageFromTransform = `
    //   translate(${ideltaX}px, ${ideltaY}px)
    //   scale(${ideltaW}, ${ideltaH})
    //   `
    //   let toTransform = `
    //   translate(0,0)
    //   scale(1,1)
    //   `;
    //   // Animate
    //   var tl = new TimelineLite({ paused: true });
    //   // Put the destination pieces in their "First" states
    //   TweenLite.set(animLabelDest, {transform: fromTransform, transformOrigin: "left top"});
    //   TweenLite.set(animImageDest, {transform: imageFromTransform, transformOrigin: "right top"});
    //
    //   let unskewDuration = 0.15;
    //   var delay = 0;
    //   tl.addLabel("unskewLabel", delay);
    //   delay += unskewDuration;
    //
    //   let scaleUpLabelDuration = 0.15;
    //   tl.addLabel("scaleUpLabel", delay);
    //   delay += scaleUpLabelDuration;
    //
    //   delay = 0.01; // reset
    //   let fadeOutImageDuration = 0.25;
    //   tl.addLabel("fadeOutImage", delay);
    //   delay += fadeOutImageDuration;
    //
    //   let unskewContentDuration = 0.15;
    //   tl.addLabel("unskewContentDuration", delay);
    //   delay += unskewContentDuration;
    //
    //   let scaleUpContentDuration = 0.15;
    //   tl.addLabel("scaleUpContent", delay);
    //   delay += scaleUpContentDuration;
    //
    //   // Unskew Label
    //   tl.add( TweenLite.to(this.$.label, unskewDuration, { alpha: 0 }), "unskewLabel");
    //   tl.add( TweenLite.to(this.$.labelShadow, unskewDuration, {skewY: 3, skewType: "simple", transformOrigin: "left top",
    //   force3D: true, // fixes glitch in Safari
    //   onUpdate: () => {
    //     let skewY = -this.$.labelShadow._gsTransform.skewY;
    //     TweenLite.set(this.$.label, {skewY: skewY, skewType: "simple", transformOrigin: "left top"});
    //   },
    //   onComplete: () => {
    //     animLabelDest.style.visibility = "";
    //     animLabelDest.querySelector(".label").style.visibility = "hidden";
    //     animLabelSource.style.visibility = "hidden";
    //   },
    //   ease: Power3.easeIn,
    // }), "unskewLabel");
    // // Scale Up Label
    // tl.add( TweenLite.to(animLabelDest, scaleUpLabelDuration,
    //   { transform: toTransform,
    //     transformOrigin: "left top",
    //     force3D: true,
    //     ease: Power3.easeOut,
    //   }), "scaleUpLabel");
    //   // Fade Out the content Image
    //   tl.add( TweenLite.to(this.$.content, fadeOutImageDuration,
    //     {
    //       backgroundImage: '',
    //       // backgroundColor: '#54F0CE',
    //       ease: Power3.easeInOut,
    //     }), "fadeOutImage");
    //     // Unskew
    //     tl.add( TweenLite.to(this.$.content, unskewContentDuration,
    //       {
    //         skewY: 3, skewType: "simple", transformOrigin: "right top",
    //         onUpdate: () => {
    //
    //         }, onComplete: () => {
    //           animImageDest.style.visibility = "";
    //           let content = animImageDest.querySelector(".content");
    //           content.style.backgroundImage = "";
    //           // content.style.backgroundColor = "#54F0CE";
    //           animImageSource.style.visibility = "hidden";
    //         },
    //         ease: Power3.easeIn,
    //       }), "unskewContentDuration");
    //     // Scale Up
    //     tl.add( TweenLite.to(animImageDest, scaleUpContentDuration, {transform: toTransform,
    //     force3D: true, // fixes glitch in Safari
    //     onUpdate: () => {
    //       let sx = 1.0/animLabelDest._gsTransform.scaleX;
    //       let sy = 1.0/animLabelDest._gsTransform.scaleY;
    //       let content = animImageDest.children[0];
    //       // let content = animImageDest.querySelector(".content");
    //       TweenLite.set(content, { scaleX: sx, scaleY: sy, transformOrigin: "right top"});
    //     }, onComplete: () => {
    //       setTimeout(() => {
    //         callback(animLabelDest,animImageDest);
    //       },1);
    //     },
    //     ease: Power3.easeOut,
    //   }), "scaleUpContent");
    //   tl.restart();
    }

    openCard(event, callback) {
      if (event.target != event.currentTarget) {
        return;
      }
      if (!this.domReady) {
        return;
      }
      event.preventDefault();
      this._openCard(callback);
    }

    closeCard(event, callback) {
      console.log("C");
      if (event.target != event.currentTarget) {
        return;
      }
      console.log("D");
      if (!this.domReady) {
        return;
      }
      console.log("E");
      event.preventDefault();
      this._closeCard(callback);
    }

    _popState(event) {
      if (event.target != event.currentTarget || !this.state) {
        return; // event is window so this probably isn't necessary
      }
      event.preventDefault();
      this._openCard();
    }

    _loadImage(img) {
      if (img && !img.src) {
        img.src = img.getAttribute('data-src');
      }
    }
  }
  window.customElements.define(SkewCard.is, SkewCard);
  </script>
</dom-module>
